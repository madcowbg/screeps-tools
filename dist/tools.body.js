// Generated by CoffeeScript 2.3.2
var _, _bodyRepeat, bodyPlanCost, maxRepeat, optimizedWorkerOfPower;

_ = require('lodash');

module.exports.creepDesign = {
  versatileWorker: function(energyAvailable, opts) {
    return maxRepeat([WORK, CARRY, MOVE], energyAvailable, opts);
  },
  courier: function(energyAvailable, opts) {
    return maxRepeat([CARRY, MOVE], energyAvailable, opts);
  },
  slowCourier: function(energyAvailable, opts) {
    if (opts.maxPower != null) {
      opts.maxPower = Math.ceil(opts.maxPower / 2); // since we multiply it twice...
    }
    if (opts.minPower != null) {
      opts.minPower = Math.ceil(opts.minPower / 2);
    }
    return maxRepeat([CARRY, CARRY, MOVE], energyAvailable, opts);
  },
  observer: function(energyAvailable, opts) {
    if (energyAvailable >= BODYPART_COST[MOVE]) {
      return [MOVE];
    }
  },
  claimer: function(energyAvailable, opts) {
    if (energyAvailable >= BODYPART_COST[MOVE] + BODYPART_COST[CLAIM]) {
      return [MOVE, CLAIM];
    } else {
      return [];
    }
  },
  optimizedWorker: function(energyAvailable, opts) {
    var n;
    opts = _.defaults(opts, {
      minPower: 1,
      maxPower: 50
    });
    return _.last(_.filter((function() {
      var i, ref, ref1, results;
      results = [];
      for (n = i = ref = opts.minPower, ref1 = opts.maxPower; (ref <= ref1 ? i <= ref1 : i >= ref1); n = ref <= ref1 ? ++i : --i) {
        results.push(optimizedWorkerOfPower(n));
      }
      return results;
    })(), function(v) {
      return bodyPlanCost(v) <= energyAvailable && v.length <= 50;
    }));
  },
  optimizedMiner: function(energyAvailable, opts) {
    var n;
    opts = _.defaults(opts, {
      minPower: 1,
      maxPower: 50
    });
    return _.last(_.filter((function() {
      var i, ref, ref1, results;
      results = [];
      for (n = i = ref = opts.minPower, ref1 = opts.maxPower; (ref <= ref1 ? i <= ref1 : i >= ref1); n = ref <= ref1 ? ++i : --i) {
        results.push(optimizedWorkerOfPower(n, true));
      }
      return results;
    })(), function(v) {
      return bodyPlanCost(v) <= energyAvailable && v.length <= 50;
    }));
  }
};

module.exports.bodyPlanCost = bodyPlanCost = function(bodyPlan) {
  var type;
  return _.sum((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = bodyPlan.length; i < len; i++) {
      type = bodyPlan[i];
      results.push(BODYPART_COST[type]);
    }
    return results;
  })());
};

maxRepeat = function(basicBodyPlan, energyAvailable, opts = {}) {
  var power, ref;
  opts = _.defaults(opts, {
    minPower: 1,
    maxPower: 50
  });
  if (!(0 <= energyAvailable && (1 <= (ref = opts.minPower) && ref <= opts.maxPower))) {
    throw new Error(`invalid energy ${energyAvailable} or max power ${opts.maxPower}.`);
  }
  power = Math.min(opts.maxPower, Math.floor(50 / basicBodyPlan.length), Math.floor(energyAvailable / bodyPlanCost(basicBodyPlan)));
  if (power >= opts.minPower) {
    return _bodyRepeat(basicBodyPlan, power);
  }
};

_bodyRepeat = function(body, n) {
  var part;
  return _.flatten((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = body.length; i < len; i++) {
      part = body[i];
      results.push((function() {
        var j, ref, results1;
        results1 = [];
        for (j = 1, ref = n; (1 <= ref ? j <= ref : j >= ref); 1 <= ref ? j++ : j--) {
          results1.push(part);
        }
        return results1;
      })());
    }
    return results;
  })());
};

optimizedWorkerOfPower = function(n, ignoreCarry = false, k = 3) {
  var bodyPlan, ncarry, nmove;
  ncarry = ignoreCarry ? 1 : Math.ceil(n / k);
  nmove = Math.ceil((n + (ignoreCarry ? 0 : ncarry)) / 2);
  bodyPlan = [...(_.fill(Array(n), WORK)), ...(_.fill(Array(ncarry), CARRY)), ...(_.fill(Array(nmove), MOVE))];
  // log.debug "power #{n} results in creep #{bodyPlan}"
  return bodyPlan;
};
