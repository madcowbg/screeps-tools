// Generated by CoffeeScript 2.3.2
var _, cacheKey, isCorrectKey, keyFromVal, memoizeByCache, memoizeForTick, memoizeGlobal, resetMemoized;

_ = require('lodash');

keyFromVal = function(a, i) {
  return `{${i}:${typeof a}:${a}}`;
};

isCorrectKey = function(a) {
  return typeof a !== 'number' && typeof a !== 'string';
};

cacheKey = function(args) {
  if (args.length === 0) {
    return "{}";
  }
  if (args.length === 1 && (typeof args[0] === 'string' || typeof args[0] === 'number')) {
    return keyFromVal(args[0], 0);
  }
  if ((_.filter(args, isCorrectKey)).length > 0) {
    throw new TypeError(`bad parameters of memoized function: ${JSON.stringify(args)}`);
  }
  return (_.map(args, keyFromVal)).join(", ");
};

memoizeGlobal = {
  init: function() {
    return (global.cache != null ? global.cache : global.cache = {}).memoize = {
      valid: true,
      vals: {}
    };
  },
  obtain: function() {
    return global.cache.memoize;
  }
};

memoizeForTick = {
  init: function() {
    return (global.cache != null ? global.cache : global.cache = {}).memoizeForTick = {
      time: Game.time,
      vals: {}
    };
  },
  obtain: function() {
    var cache, descriptor, ref, v;
    cache = global.cache.memoizeForTick;
    if (cache.time !== Game.time) {
      ref = cache.vals;
      for (descriptor in ref) {
        v = ref[descriptor];
        cache.vals[descriptor] = {};
      }
      cache.time = Game.time;
    }
    return cache;
  }
};

memoizeByCache = function(memoize) {
  return function(descriptor, argn, f) {
    if (memoize.obtain().vals[descriptor] != null) {
      throw new Error(`duplicate memoization requested: ${descriptor}`);
    }
    if (!((descriptor != null) && typeof f === 'function')) {
      throw new Error(`invalid descriptor ${descriptor} or function ${f}`);
    }
    memoize.obtain().vals[descriptor] = {};
    return function(...args) {
      var a, cache, e, j, len;
      if (args.length !== argn) {
        throw new Error(`Invalid number of arguments: ${args.length}, expected ${argn}`);
      }
      cache = memoize.obtain().vals[descriptor];
      if (cache == null) {
        throw new Error("cache invalidated!");
      }
      for (j = 0, len = args.length; j < len; j++) {
        a = args[j];
        cache = (cache[a] != null ? cache[a] : cache[a] = {});
      }
      if (cache.hasOwnProperty("error")) {
        throw cache.error;
      }
      if (!cache.hasOwnProperty("val")) {
        try {
          cache.val = f(...args);
        } catch (error) {
          e = error;
          cache.error = new Error(e);
          throw cache.error;
        }
      }
      return cache.val;
    };
  };
};

resetMemoized = function() {
  memoizeGlobal.init();
  return memoizeForTick.init();
};

resetMemoized();

module.exports.memoize = memoizeByCache(memoizeGlobal);

module.exports.memoizeForTick = memoizeByCache(memoizeForTick);

module.exports.invalidateMemoized = resetMemoized;
